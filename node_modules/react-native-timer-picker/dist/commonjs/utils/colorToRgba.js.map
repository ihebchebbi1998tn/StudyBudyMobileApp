{"version":3,"names":["colorToRgba","variables","color","opacity","namedColors","transparent","black","white","blue","green","gray","red","startsWith","rgbValues","replace","split","map","value","parseInt","trim","r","g","b","hexColor","slice","length","join","exports"],"sources":["colorToRgba.ts"],"sourcesContent":["export const colorToRgba = (variables: { color: string; opacity?: number }) => {\n    // this function is required for expo-linear-gradient on iOS. To fade to transparent, we need\n    // to be able to add opacity to the background color. Supplying 'transparent' does not work\n    // because that is actually a transparent black (rgba(0, 0, 0, 1)), which results in dodgy rendering\n\n    const { color, opacity = 1 } = variables;\n    // Handle named colors\n    const namedColors: { [key: string]: string } = {\n        transparent: \"rgba(0, 0, 0, 0)\",\n        black: \"rgba(0, 0, 0, 1)\",\n        white: \"rgba(255, 255, 255, 1)\",\n        blue: \"rgba(0, 0, 255, 1)\",\n        green: \"rgba(0, 128, 0, 1)\",\n        gray: \"rgba(128, 128, 128, 1)\",\n        red: \"rgba(255, 0, 0, 1)\",\n    };\n\n    if (color in namedColors) {\n        return namedColors[color];\n    }\n\n    // Handle RGB format\n    if (color.startsWith(\"rgb(\")) {\n        const rgbValues = color\n            .replace(\"rgb(\", \"\")\n            .replace(\")\", \"\")\n            .split(\",\")\n            .map((value) => parseInt(value.trim(), 10));\n        const [r, g, b] = rgbValues;\n        return `rgba(${r}, ${g}, ${b}, ${opacity})`;\n    }\n\n    // Handle hex format\n    if (color.startsWith(\"#\")) {\n        let hexColor = color.slice(1);\n        if (hexColor.length === 3) {\n            hexColor = hexColor\n                .split(\"\")\n                .map((value) => value + value)\n                .join(\"\");\n        }\n        const r = parseInt(hexColor.slice(0, 2), 16);\n        const g = parseInt(hexColor.slice(2, 4), 16);\n        const b = parseInt(hexColor.slice(4, 6), 16);\n        return `rgba(${r}, ${g}, ${b}, ${opacity})`;\n    }\n\n    return color; // Return unchanged if unable to parse\n};\n"],"mappings":";;;;;;AAAO,MAAMA,WAAW,GAAIC,SAA8C,IAAK;EAC3E;EACA;EACA;;EAEA,MAAM;IAAEC,KAAK;IAAEC,OAAO,GAAG;EAAE,CAAC,GAAGF,SAAS;EACxC;EACA,MAAMG,WAAsC,GAAG;IAC3CC,WAAW,EAAE,kBAAkB;IAC/BC,KAAK,EAAE,kBAAkB;IACzBC,KAAK,EAAE,wBAAwB;IAC/BC,IAAI,EAAE,oBAAoB;IAC1BC,KAAK,EAAE,oBAAoB;IAC3BC,IAAI,EAAE,wBAAwB;IAC9BC,GAAG,EAAE;EACT,CAAC;EAED,IAAIT,KAAK,IAAIE,WAAW,EAAE;IACtB,OAAOA,WAAW,CAACF,KAAK,CAAC;EAC7B;;EAEA;EACA,IAAIA,KAAK,CAACU,UAAU,CAAC,MAAM,CAAC,EAAE;IAC1B,MAAMC,SAAS,GAAGX,KAAK,CAClBY,OAAO,CAAC,MAAM,EAAE,EAAE,CAAC,CACnBA,OAAO,CAAC,GAAG,EAAE,EAAE,CAAC,CAChBC,KAAK,CAAC,GAAG,CAAC,CACVC,GAAG,CAAEC,KAAK,IAAKC,QAAQ,CAACD,KAAK,CAACE,IAAI,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;IAC/C,MAAM,CAACC,CAAC,EAAEC,CAAC,EAAEC,CAAC,CAAC,GAAGT,SAAS;IAC3B,OAAQ,QAAOO,CAAE,KAAIC,CAAE,KAAIC,CAAE,KAAInB,OAAQ,GAAE;EAC/C;;EAEA;EACA,IAAID,KAAK,CAACU,UAAU,CAAC,GAAG,CAAC,EAAE;IACvB,IAAIW,QAAQ,GAAGrB,KAAK,CAACsB,KAAK,CAAC,CAAC,CAAC;IAC7B,IAAID,QAAQ,CAACE,MAAM,KAAK,CAAC,EAAE;MACvBF,QAAQ,GAAGA,QAAQ,CACdR,KAAK,CAAC,EAAE,CAAC,CACTC,GAAG,CAAEC,KAAK,IAAKA,KAAK,GAAGA,KAAK,CAAC,CAC7BS,IAAI,CAAC,EAAE,CAAC;IACjB;IACA,MAAMN,CAAC,GAAGF,QAAQ,CAACK,QAAQ,CAACC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,EAAE,CAAC;IAC5C,MAAMH,CAAC,GAAGH,QAAQ,CAACK,QAAQ,CAACC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,EAAE,CAAC;IAC5C,MAAMF,CAAC,GAAGJ,QAAQ,CAACK,QAAQ,CAACC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,EAAE,CAAC;IAC5C,OAAQ,QAAOJ,CAAE,KAAIC,CAAE,KAAIC,CAAE,KAAInB,OAAQ,GAAE;EAC/C;EAEA,OAAOD,KAAK,CAAC,CAAC;AAClB,CAAC;AAACyB,OAAA,CAAA3B,WAAA,GAAAA,WAAA"}