"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _react = _interopRequireWildcard(require("react"));
var _reactNative = require("react-native");
var _generateNumbers = require("../../utils/generateNumbers");
var _colorToRgba = require("../../utils/colorToRgba");
var _getAdjustedLimit = require("../../utils/getAdjustedLimit");
var _getScrollIndex = require("../../utils/getScrollIndex");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const KEY_EXTRACTOR = (_, index) => index.toString();
const DurationScroll = /*#__PURE__*/(0, _react.forwardRef)(({
  numberOfItems,
  label,
  initialValue = 0,
  onDurationChange,
  padNumbersWithZero = false,
  disableInfiniteScroll = false,
  limit,
  isDisabled,
  aggressivelyGetLatestDuration,
  allowFontScaling = false,
  is12HourPicker,
  amLabel,
  pmLabel,
  padWithNItems,
  pickerGradientOverlayProps,
  topPickerGradientOverlayProps,
  bottomPickerGradientOverlayProps,
  LinearGradient,
  testID,
  styles
}, ref) => {
  const data = !is12HourPicker ? (0, _generateNumbers.generateNumbers)(numberOfItems, {
    padNumbersWithZero,
    repeatNTimes: 3,
    disableInfiniteScroll,
    padWithNItems
  }) : (0, _generateNumbers.generate12HourNumbers)({
    padNumbersWithZero,
    repeatNTimes: 3,
    disableInfiniteScroll,
    padWithNItems
  });
  const numberOfItemsToShow = 1 + padWithNItems * 2;
  const adjustedLimited = (0, _getAdjustedLimit.getAdjustedLimit)(limit, numberOfItems);
  const initialScrollIndex = (0, _getScrollIndex.getScrollIndex)({
    value: initialValue,
    numberOfItems,
    padWithNItems,
    disableInfiniteScroll
  });
  const latestDuration = (0, _react.useRef)(0);
  const flatListRef = (0, _react.useRef)(null);
  (0, _react.useImperativeHandle)(ref, () => ({
    reset: options => {
      var _flatListRef$current;
      (_flatListRef$current = flatListRef.current) === null || _flatListRef$current === void 0 || _flatListRef$current.scrollToIndex({
        animated: (options === null || options === void 0 ? void 0 : options.animated) ?? false,
        index: initialScrollIndex
      });
    },
    setValue: (value, options) => {
      var _flatListRef$current2;
      (_flatListRef$current2 = flatListRef.current) === null || _flatListRef$current2 === void 0 || _flatListRef$current2.scrollToIndex({
        animated: (options === null || options === void 0 ? void 0 : options.animated) ?? false,
        index: (0, _getScrollIndex.getScrollIndex)({
          value: value,
          numberOfItems,
          padWithNItems,
          disableInfiniteScroll
        })
      });
    },
    latestDuration: latestDuration
  }));
  const renderItem = (0, _react.useCallback)(({
    item
  }) => {
    let stringItem = item;
    let intItem;
    let isAm;
    if (!is12HourPicker) {
      intItem = parseInt(item);
    } else {
      isAm = item.includes("AM");
      stringItem = item.replace(/\s[AP]M/g, "");
      intItem = parseInt(stringItem);
    }
    return /*#__PURE__*/_react.default.createElement(_reactNative.View, {
      key: item,
      style: styles.pickerItemContainer,
      testID: "picker-item"
    }, /*#__PURE__*/_react.default.createElement(_reactNative.Text, {
      allowFontScaling: allowFontScaling,
      style: [styles.pickerItem, intItem > adjustedLimited.max || intItem < adjustedLimited.min ? styles.disabledPickerItem : {}]
    }, stringItem), is12HourPicker ? /*#__PURE__*/_react.default.createElement(_reactNative.View, {
      style: styles.pickerAmPmContainer,
      pointerEvents: "none"
    }, /*#__PURE__*/_react.default.createElement(_reactNative.Text, {
      style: [styles.pickerAmPmLabel],
      allowFontScaling: allowFontScaling
    }, isAm ? amLabel : pmLabel)) : null);
  }, [adjustedLimited.max, adjustedLimited.min, allowFontScaling, amLabel, is12HourPicker, pmLabel, styles.disabledPickerItem, styles.pickerAmPmContainer, styles.pickerAmPmLabel, styles.pickerItem, styles.pickerItemContainer]);
  const onScroll = (0, _react.useCallback)(e => {
    // this function is only used when the picker is in a modal
    // it is used to ensure that the modal gets the latest duration on clicking
    // the confirm button, even if the scrollview is still scrolling
    const newIndex = Math.round(e.nativeEvent.contentOffset.y / styles.pickerItemContainer.height);
    let newDuration = (disableInfiniteScroll ? newIndex : newIndex + padWithNItems) % (numberOfItems + 1);

    // check limits
    if (newDuration > adjustedLimited.max) {
      newDuration = adjustedLimited.max;
    } else if (newDuration < adjustedLimited.min) {
      newDuration = adjustedLimited.min;
    }
    latestDuration.current = newDuration;
  }, [adjustedLimited.max, adjustedLimited.min, disableInfiniteScroll, numberOfItems, padWithNItems, styles.pickerItemContainer.height]);
  const onMomentumScrollEnd = (0, _react.useCallback)(e => {
    const newIndex = Math.round(e.nativeEvent.contentOffset.y / styles.pickerItemContainer.height);
    let newDuration = (disableInfiniteScroll ? newIndex : newIndex + padWithNItems) % (numberOfItems + 1);

    // check limits
    if (newDuration > adjustedLimited.max) {
      var _flatListRef$current3;
      const targetScrollIndex = newIndex - (newDuration - adjustedLimited.max);
      (_flatListRef$current3 = flatListRef.current) === null || _flatListRef$current3 === void 0 || _flatListRef$current3.scrollToIndex({
        animated: true,
        index:
        // guard against scrolling beyond end of list
        targetScrollIndex >= 0 ? targetScrollIndex : adjustedLimited.max - 1
      }); // scroll down to max
      newDuration = adjustedLimited.max;
    } else if (newDuration < adjustedLimited.min) {
      var _flatListRef$current4;
      const targetScrollIndex = newIndex + (adjustedLimited.min - newDuration);
      (_flatListRef$current4 = flatListRef.current) === null || _flatListRef$current4 === void 0 || _flatListRef$current4.scrollToIndex({
        animated: true,
        index:
        // guard against scrolling beyond end of list
        targetScrollIndex <= data.length - 1 ? targetScrollIndex : adjustedLimited.min
      }); // scroll up to min
      newDuration = adjustedLimited.min;
    }
    onDurationChange(newDuration);
  }, [adjustedLimited.max, adjustedLimited.min, data.length, disableInfiniteScroll, numberOfItems, onDurationChange, padWithNItems, styles.pickerItemContainer.height]);
  const onViewableItemsChanged = (0, _react.useCallback)(({
    viewableItems
  }) => {
    var _viewableItems$, _viewableItems$2;
    if ((_viewableItems$ = viewableItems[0]) !== null && _viewableItems$ !== void 0 && _viewableItems$.index && viewableItems[0].index < numberOfItems * 0.5) {
      var _flatListRef$current5;
      (_flatListRef$current5 = flatListRef.current) === null || _flatListRef$current5 === void 0 || _flatListRef$current5.scrollToIndex({
        animated: false,
        index: viewableItems[0].index + numberOfItems
      });
    } else if ((_viewableItems$2 = viewableItems[0]) !== null && _viewableItems$2 !== void 0 && _viewableItems$2.index && viewableItems[0].index >= numberOfItems * 2.5) {
      var _flatListRef$current6;
      (_flatListRef$current6 = flatListRef.current) === null || _flatListRef$current6 === void 0 || _flatListRef$current6.scrollToIndex({
        animated: false,
        index: viewableItems[0].index - numberOfItems
      });
    }
  }, [numberOfItems]);
  const getItemLayout = (0, _react.useCallback)((_, index) => ({
    length: styles.pickerItemContainer.height,
    offset: styles.pickerItemContainer.height * index,
    index
  }), [styles.pickerItemContainer.height]);
  const viewabilityConfigCallbackPairs = (0, _react.useRef)([{
    viewabilityConfig: {
      viewAreaCoveragePercentThreshold: 25
    },
    onViewableItemsChanged: onViewableItemsChanged
  }]);
  return /*#__PURE__*/_react.default.createElement(_reactNative.View, {
    testID: testID,
    pointerEvents: isDisabled ? "none" : undefined,
    style: [{
      height: styles.pickerItemContainer.height * numberOfItemsToShow,
      overflow: "visible"
    }, isDisabled && styles.disabledPickerContainer]
  }, /*#__PURE__*/_react.default.createElement(_reactNative.FlatList, {
    ref: flatListRef,
    data: data,
    getItemLayout: getItemLayout,
    initialScrollIndex: initialScrollIndex,
    windowSize: numberOfItemsToShow,
    renderItem: renderItem,
    keyExtractor: KEY_EXTRACTOR,
    showsVerticalScrollIndicator: false,
    decelerationRate: 0.88,
    scrollEventThrottle: 16,
    snapToAlignment: "start",
    scrollEnabled: !isDisabled
    // used in place of snapToOffset due to bug on Android
    ,
    snapToOffsets: [...Array(data.length)].map((_, i) => i * styles.pickerItemContainer.height),
    viewabilityConfigCallbackPairs: !disableInfiniteScroll ? viewabilityConfigCallbackPairs === null || viewabilityConfigCallbackPairs === void 0 ? void 0 : viewabilityConfigCallbackPairs.current : undefined,
    onMomentumScrollEnd: onMomentumScrollEnd,
    onScroll: aggressivelyGetLatestDuration ? onScroll : undefined,
    testID: "duration-scroll-flatlist"
  }), /*#__PURE__*/_react.default.createElement(_reactNative.View, {
    style: styles.pickerLabelContainer,
    pointerEvents: "none"
  }, typeof label === "string" ? /*#__PURE__*/_react.default.createElement(_reactNative.Text, {
    allowFontScaling: allowFontScaling,
    style: styles.pickerLabel
  }, label) : label ?? null), LinearGradient ? /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement(LinearGradient, _extends({
    colors: [styles.pickerContainer.backgroundColor ?? "white", (0, _colorToRgba.colorToRgba)({
      color: styles.pickerContainer.backgroundColor ?? "white",
      opacity: 0
    })],
    start: {
      x: 1,
      y: 0.3
    },
    end: {
      x: 1,
      y: 1
    },
    pointerEvents: "none"
  }, pickerGradientOverlayProps, topPickerGradientOverlayProps, {
    style: [styles.pickerGradientOverlay, {
      top: 0
    }]
  })), /*#__PURE__*/_react.default.createElement(LinearGradient, _extends({
    colors: [(0, _colorToRgba.colorToRgba)({
      color: styles.pickerContainer.backgroundColor ?? "white",
      opacity: 0
    }), styles.pickerContainer.backgroundColor ?? "white"],
    start: {
      x: 1,
      y: 0
    },
    end: {
      x: 1,
      y: 0.7
    },
    pointerEvents: "none"
  }, pickerGradientOverlayProps, bottomPickerGradientOverlayProps, {
    style: [styles.pickerGradientOverlay, {
      bottom: -1
    }]
  }))) : null);
});
var _default = exports.default = /*#__PURE__*/_react.default.memo(DurationScroll);
//# sourceMappingURL=DurationScroll.js.map