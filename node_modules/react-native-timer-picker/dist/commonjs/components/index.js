"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _react = _interopRequireWildcard(require("react"));
var _reactNative = require("react-native");
var _TimerPicker = _interopRequireDefault(require("./TimerPicker"));
var _Modal = _interopRequireDefault(require("./Modal"));
var _TimerPickerModal = require("./TimerPickerModal.styles");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
const TimerPickerModal = /*#__PURE__*/(0, _react.forwardRef)(({
  visible,
  setIsVisible,
  onConfirm,
  onCancel,
  onDurationChange,
  closeOnOverlayPress,
  initialHours = 0,
  initialMinutes = 0,
  initialSeconds = 0,
  hideHours = false,
  hideMinutes = false,
  hideSeconds = false,
  hoursPickerIsDisabled = false,
  minutesPickerIsDisabled = false,
  secondsPickerIsDisabled = false,
  hourLimit,
  minuteLimit,
  secondLimit,
  hourLabel,
  minuteLabel,
  secondLabel,
  padWithNItems = 1,
  disableInfiniteScroll = false,
  allowFontScaling = false,
  use12HourPicker,
  amLabel,
  pmLabel,
  hideCancelButton = false,
  confirmButtonText = "Confirm",
  cancelButtonText = "Cancel",
  modalTitle,
  LinearGradient,
  modalProps,
  containerProps,
  contentContainerProps,
  pickerContainerProps,
  buttonContainerProps,
  buttonTouchableOpacityProps,
  modalTitleProps,
  pickerGradientOverlayProps,
  topPickerGradientOverlayProps,
  bottomPickerGradientOverlayProps,
  styles: customStyles
}, ref) => {
  const styles = (0, _TimerPickerModal.generateStyles)(customStyles);
  const timerPickerRef = (0, _react.useRef)(null);
  const [selectedDuration, setSelectedDuration] = (0, _react.useState)({
    hours: initialHours,
    minutes: initialMinutes,
    seconds: initialSeconds
  });
  const [confirmedDuration, setConfirmedDuration] = (0, _react.useState)({
    hours: initialHours,
    minutes: initialMinutes,
    seconds: initialSeconds
  });
  const reset = options => {
    var _timerPickerRef$curre;
    const initialDuration = {
      hours: initialHours,
      minutes: initialMinutes,
      seconds: initialSeconds
    };
    setSelectedDuration(initialDuration);
    setConfirmedDuration(initialDuration);
    (_timerPickerRef$curre = timerPickerRef.current) === null || _timerPickerRef$curre === void 0 || _timerPickerRef$curre.reset(options);
  };

  // reset state if the initial times change
  (0, _react.useEffect)(() => {
    reset();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [initialHours, initialMinutes, initialSeconds]);
  const hideModalHandler = () => {
    setSelectedDuration({
      hours: confirmedDuration.hours,
      minutes: confirmedDuration.minutes,
      seconds: confirmedDuration.seconds
    });
    setIsVisible(false);
  };
  const confirmHandler = () => {
    var _timerPickerRef$curre2, _latestDuration$hours, _latestDuration$minut, _latestDuration$secon;
    const latestDuration = (_timerPickerRef$curre2 = timerPickerRef.current) === null || _timerPickerRef$curre2 === void 0 ? void 0 : _timerPickerRef$curre2.latestDuration;
    const newDuration = {
      hours: (latestDuration === null || latestDuration === void 0 || (_latestDuration$hours = latestDuration.hours) === null || _latestDuration$hours === void 0 ? void 0 : _latestDuration$hours.current) ?? selectedDuration.hours,
      minutes: (latestDuration === null || latestDuration === void 0 || (_latestDuration$minut = latestDuration.minutes) === null || _latestDuration$minut === void 0 ? void 0 : _latestDuration$minut.current) ?? selectedDuration.minutes,
      seconds: (latestDuration === null || latestDuration === void 0 || (_latestDuration$secon = latestDuration.seconds) === null || _latestDuration$secon === void 0 ? void 0 : _latestDuration$secon.current) ?? selectedDuration.seconds
    };
    setConfirmedDuration(newDuration);
    onConfirm(newDuration);
  };
  const cancelHandler = () => {
    setIsVisible(false);
    setSelectedDuration(confirmedDuration);
    onCancel === null || onCancel === void 0 || onCancel();
  };

  // wrapped in useCallback to avoid unnecessary re-renders of TimerPicker
  const durationChangeHandler = (0, _react.useCallback)(duration => {
    setSelectedDuration(duration);
    onDurationChange === null || onDurationChange === void 0 || onDurationChange(duration);
  }, [onDurationChange]);
  (0, _react.useImperativeHandle)(ref, () => {
    var _timerPickerRef$curre4, _timerPickerRef$curre5, _timerPickerRef$curre6;
    return {
      reset,
      setValue: (value, options) => {
        var _timerPickerRef$curre3;
        setSelectedDuration(value);
        setConfirmedDuration(value);
        (_timerPickerRef$curre3 = timerPickerRef.current) === null || _timerPickerRef$curre3 === void 0 || _timerPickerRef$curre3.setValue(value, options);
      },
      latestDuration: {
        hours: (_timerPickerRef$curre4 = timerPickerRef.current) === null || _timerPickerRef$curre4 === void 0 || (_timerPickerRef$curre4 = _timerPickerRef$curre4.latestDuration) === null || _timerPickerRef$curre4 === void 0 ? void 0 : _timerPickerRef$curre4.hours,
        minutes: (_timerPickerRef$curre5 = timerPickerRef.current) === null || _timerPickerRef$curre5 === void 0 || (_timerPickerRef$curre5 = _timerPickerRef$curre5.latestDuration) === null || _timerPickerRef$curre5 === void 0 ? void 0 : _timerPickerRef$curre5.minutes,
        seconds: (_timerPickerRef$curre6 = timerPickerRef.current) === null || _timerPickerRef$curre6 === void 0 || (_timerPickerRef$curre6 = _timerPickerRef$curre6.latestDuration) === null || _timerPickerRef$curre6 === void 0 ? void 0 : _timerPickerRef$curre6.seconds
      }
    };
  });
  return /*#__PURE__*/_react.default.createElement(_Modal.default, _extends({
    isVisible: visible,
    onOverlayPress: closeOnOverlayPress ? hideModalHandler : undefined
  }, modalProps, {
    testID: "timer-picker-modal"
  }), /*#__PURE__*/_react.default.createElement(_reactNative.View, _extends({}, containerProps, {
    style: styles.container
  }), /*#__PURE__*/_react.default.createElement(_reactNative.View, _extends({}, contentContainerProps, {
    style: styles.contentContainer
  }), modalTitle ? /*#__PURE__*/_react.default.createElement(_reactNative.Text, _extends({}, modalTitleProps, {
    style: styles.modalTitle
  }), modalTitle) : null, /*#__PURE__*/_react.default.createElement(_TimerPicker.default, {
    ref: timerPickerRef,
    onDurationChange: durationChangeHandler,
    initialHours: confirmedDuration.hours,
    initialMinutes: confirmedDuration.minutes,
    initialSeconds: confirmedDuration.seconds,
    aggressivelyGetLatestDuration: true,
    hideHours: hideHours,
    hideMinutes: hideMinutes,
    hideSeconds: hideSeconds,
    hoursPickerIsDisabled: hoursPickerIsDisabled,
    minutesPickerIsDisabled: minutesPickerIsDisabled,
    secondsPickerIsDisabled: secondsPickerIsDisabled,
    hourLimit: hourLimit,
    minuteLimit: minuteLimit,
    secondLimit: secondLimit,
    hourLabel: hourLabel,
    minuteLabel: minuteLabel,
    secondLabel: secondLabel,
    padWithNItems: padWithNItems,
    disableInfiniteScroll: disableInfiniteScroll,
    allowFontScaling: allowFontScaling,
    use12HourPicker: use12HourPicker,
    amLabel: amLabel,
    pmLabel: pmLabel,
    LinearGradient: LinearGradient,
    pickerContainerProps: pickerContainerProps,
    pickerGradientOverlayProps: pickerGradientOverlayProps,
    topPickerGradientOverlayProps: topPickerGradientOverlayProps,
    bottomPickerGradientOverlayProps: bottomPickerGradientOverlayProps,
    styles: customStyles
  }), /*#__PURE__*/_react.default.createElement(_reactNative.View, _extends({}, buttonContainerProps, {
    style: styles.buttonContainer
  }), !hideCancelButton ? /*#__PURE__*/_react.default.createElement(_reactNative.TouchableOpacity, _extends({
    onPress: cancelHandler
  }, buttonTouchableOpacityProps), /*#__PURE__*/_react.default.createElement(_reactNative.Text, {
    style: [styles.button, styles.cancelButton]
  }, cancelButtonText)) : null, /*#__PURE__*/_react.default.createElement(_reactNative.TouchableOpacity, _extends({
    onPress: confirmHandler
  }, buttonTouchableOpacityProps), /*#__PURE__*/_react.default.createElement(_reactNative.Text, {
    style: [styles.button, styles.confirmButton]
  }, confirmButtonText))))));
});
var _default = exports.default = /*#__PURE__*/_react.default.memo(TimerPickerModal);
//# sourceMappingURL=index.js.map