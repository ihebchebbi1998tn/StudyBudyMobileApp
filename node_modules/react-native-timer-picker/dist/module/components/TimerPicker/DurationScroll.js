function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
import React, { useRef, useCallback, forwardRef, useImperativeHandle } from "react";
import { View, Text, FlatList } from "react-native";
import { generate12HourNumbers, generateNumbers } from "../../utils/generateNumbers";
import { colorToRgba } from "../../utils/colorToRgba";
import { getAdjustedLimit } from "../../utils/getAdjustedLimit";
import { getScrollIndex } from "../../utils/getScrollIndex";
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const KEY_EXTRACTOR = (_, index) => index.toString();
const DurationScroll = /*#__PURE__*/forwardRef(({
  numberOfItems,
  label,
  initialValue = 0,
  onDurationChange,
  padNumbersWithZero = false,
  disableInfiniteScroll = false,
  limit,
  isDisabled,
  aggressivelyGetLatestDuration,
  allowFontScaling = false,
  is12HourPicker,
  amLabel,
  pmLabel,
  padWithNItems,
  pickerGradientOverlayProps,
  topPickerGradientOverlayProps,
  bottomPickerGradientOverlayProps,
  LinearGradient,
  testID,
  styles
}, ref) => {
  const data = !is12HourPicker ? generateNumbers(numberOfItems, {
    padNumbersWithZero,
    repeatNTimes: 3,
    disableInfiniteScroll,
    padWithNItems
  }) : generate12HourNumbers({
    padNumbersWithZero,
    repeatNTimes: 3,
    disableInfiniteScroll,
    padWithNItems
  });
  const numberOfItemsToShow = 1 + padWithNItems * 2;
  const adjustedLimited = getAdjustedLimit(limit, numberOfItems);
  const initialScrollIndex = getScrollIndex({
    value: initialValue,
    numberOfItems,
    padWithNItems,
    disableInfiniteScroll
  });
  const latestDuration = useRef(0);
  const flatListRef = useRef(null);
  useImperativeHandle(ref, () => ({
    reset: options => {
      var _flatListRef$current;
      (_flatListRef$current = flatListRef.current) === null || _flatListRef$current === void 0 || _flatListRef$current.scrollToIndex({
        animated: (options === null || options === void 0 ? void 0 : options.animated) ?? false,
        index: initialScrollIndex
      });
    },
    setValue: (value, options) => {
      var _flatListRef$current2;
      (_flatListRef$current2 = flatListRef.current) === null || _flatListRef$current2 === void 0 || _flatListRef$current2.scrollToIndex({
        animated: (options === null || options === void 0 ? void 0 : options.animated) ?? false,
        index: getScrollIndex({
          value: value,
          numberOfItems,
          padWithNItems,
          disableInfiniteScroll
        })
      });
    },
    latestDuration: latestDuration
  }));
  const renderItem = useCallback(({
    item
  }) => {
    let stringItem = item;
    let intItem;
    let isAm;
    if (!is12HourPicker) {
      intItem = parseInt(item);
    } else {
      isAm = item.includes("AM");
      stringItem = item.replace(/\s[AP]M/g, "");
      intItem = parseInt(stringItem);
    }
    return /*#__PURE__*/React.createElement(View, {
      key: item,
      style: styles.pickerItemContainer,
      testID: "picker-item"
    }, /*#__PURE__*/React.createElement(Text, {
      allowFontScaling: allowFontScaling,
      style: [styles.pickerItem, intItem > adjustedLimited.max || intItem < adjustedLimited.min ? styles.disabledPickerItem : {}]
    }, stringItem), is12HourPicker ? /*#__PURE__*/React.createElement(View, {
      style: styles.pickerAmPmContainer,
      pointerEvents: "none"
    }, /*#__PURE__*/React.createElement(Text, {
      style: [styles.pickerAmPmLabel],
      allowFontScaling: allowFontScaling
    }, isAm ? amLabel : pmLabel)) : null);
  }, [adjustedLimited.max, adjustedLimited.min, allowFontScaling, amLabel, is12HourPicker, pmLabel, styles.disabledPickerItem, styles.pickerAmPmContainer, styles.pickerAmPmLabel, styles.pickerItem, styles.pickerItemContainer]);
  const onScroll = useCallback(e => {
    // this function is only used when the picker is in a modal
    // it is used to ensure that the modal gets the latest duration on clicking
    // the confirm button, even if the scrollview is still scrolling
    const newIndex = Math.round(e.nativeEvent.contentOffset.y / styles.pickerItemContainer.height);
    let newDuration = (disableInfiniteScroll ? newIndex : newIndex + padWithNItems) % (numberOfItems + 1);

    // check limits
    if (newDuration > adjustedLimited.max) {
      newDuration = adjustedLimited.max;
    } else if (newDuration < adjustedLimited.min) {
      newDuration = adjustedLimited.min;
    }
    latestDuration.current = newDuration;
  }, [adjustedLimited.max, adjustedLimited.min, disableInfiniteScroll, numberOfItems, padWithNItems, styles.pickerItemContainer.height]);
  const onMomentumScrollEnd = useCallback(e => {
    const newIndex = Math.round(e.nativeEvent.contentOffset.y / styles.pickerItemContainer.height);
    let newDuration = (disableInfiniteScroll ? newIndex : newIndex + padWithNItems) % (numberOfItems + 1);

    // check limits
    if (newDuration > adjustedLimited.max) {
      var _flatListRef$current3;
      const targetScrollIndex = newIndex - (newDuration - adjustedLimited.max);
      (_flatListRef$current3 = flatListRef.current) === null || _flatListRef$current3 === void 0 || _flatListRef$current3.scrollToIndex({
        animated: true,
        index:
        // guard against scrolling beyond end of list
        targetScrollIndex >= 0 ? targetScrollIndex : adjustedLimited.max - 1
      }); // scroll down to max
      newDuration = adjustedLimited.max;
    } else if (newDuration < adjustedLimited.min) {
      var _flatListRef$current4;
      const targetScrollIndex = newIndex + (adjustedLimited.min - newDuration);
      (_flatListRef$current4 = flatListRef.current) === null || _flatListRef$current4 === void 0 || _flatListRef$current4.scrollToIndex({
        animated: true,
        index:
        // guard against scrolling beyond end of list
        targetScrollIndex <= data.length - 1 ? targetScrollIndex : adjustedLimited.min
      }); // scroll up to min
      newDuration = adjustedLimited.min;
    }
    onDurationChange(newDuration);
  }, [adjustedLimited.max, adjustedLimited.min, data.length, disableInfiniteScroll, numberOfItems, onDurationChange, padWithNItems, styles.pickerItemContainer.height]);
  const onViewableItemsChanged = useCallback(({
    viewableItems
  }) => {
    var _viewableItems$, _viewableItems$2;
    if ((_viewableItems$ = viewableItems[0]) !== null && _viewableItems$ !== void 0 && _viewableItems$.index && viewableItems[0].index < numberOfItems * 0.5) {
      var _flatListRef$current5;
      (_flatListRef$current5 = flatListRef.current) === null || _flatListRef$current5 === void 0 || _flatListRef$current5.scrollToIndex({
        animated: false,
        index: viewableItems[0].index + numberOfItems
      });
    } else if ((_viewableItems$2 = viewableItems[0]) !== null && _viewableItems$2 !== void 0 && _viewableItems$2.index && viewableItems[0].index >= numberOfItems * 2.5) {
      var _flatListRef$current6;
      (_flatListRef$current6 = flatListRef.current) === null || _flatListRef$current6 === void 0 || _flatListRef$current6.scrollToIndex({
        animated: false,
        index: viewableItems[0].index - numberOfItems
      });
    }
  }, [numberOfItems]);
  const getItemLayout = useCallback((_, index) => ({
    length: styles.pickerItemContainer.height,
    offset: styles.pickerItemContainer.height * index,
    index
  }), [styles.pickerItemContainer.height]);
  const viewabilityConfigCallbackPairs = useRef([{
    viewabilityConfig: {
      viewAreaCoveragePercentThreshold: 25
    },
    onViewableItemsChanged: onViewableItemsChanged
  }]);
  return /*#__PURE__*/React.createElement(View, {
    testID: testID,
    pointerEvents: isDisabled ? "none" : undefined,
    style: [{
      height: styles.pickerItemContainer.height * numberOfItemsToShow,
      overflow: "visible"
    }, isDisabled && styles.disabledPickerContainer]
  }, /*#__PURE__*/React.createElement(FlatList, {
    ref: flatListRef,
    data: data,
    getItemLayout: getItemLayout,
    initialScrollIndex: initialScrollIndex,
    windowSize: numberOfItemsToShow,
    renderItem: renderItem,
    keyExtractor: KEY_EXTRACTOR,
    showsVerticalScrollIndicator: false,
    decelerationRate: 0.88,
    scrollEventThrottle: 16,
    snapToAlignment: "start",
    scrollEnabled: !isDisabled
    // used in place of snapToOffset due to bug on Android
    ,
    snapToOffsets: [...Array(data.length)].map((_, i) => i * styles.pickerItemContainer.height),
    viewabilityConfigCallbackPairs: !disableInfiniteScroll ? viewabilityConfigCallbackPairs === null || viewabilityConfigCallbackPairs === void 0 ? void 0 : viewabilityConfigCallbackPairs.current : undefined,
    onMomentumScrollEnd: onMomentumScrollEnd,
    onScroll: aggressivelyGetLatestDuration ? onScroll : undefined,
    testID: "duration-scroll-flatlist"
  }), /*#__PURE__*/React.createElement(View, {
    style: styles.pickerLabelContainer,
    pointerEvents: "none"
  }, typeof label === "string" ? /*#__PURE__*/React.createElement(Text, {
    allowFontScaling: allowFontScaling,
    style: styles.pickerLabel
  }, label) : label ?? null), LinearGradient ? /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(LinearGradient, _extends({
    colors: [styles.pickerContainer.backgroundColor ?? "white", colorToRgba({
      color: styles.pickerContainer.backgroundColor ?? "white",
      opacity: 0
    })],
    start: {
      x: 1,
      y: 0.3
    },
    end: {
      x: 1,
      y: 1
    },
    pointerEvents: "none"
  }, pickerGradientOverlayProps, topPickerGradientOverlayProps, {
    style: [styles.pickerGradientOverlay, {
      top: 0
    }]
  })), /*#__PURE__*/React.createElement(LinearGradient, _extends({
    colors: [colorToRgba({
      color: styles.pickerContainer.backgroundColor ?? "white",
      opacity: 0
    }), styles.pickerContainer.backgroundColor ?? "white"],
    start: {
      x: 1,
      y: 0
    },
    end: {
      x: 1,
      y: 0.7
    },
    pointerEvents: "none"
  }, pickerGradientOverlayProps, bottomPickerGradientOverlayProps, {
    style: [styles.pickerGradientOverlay, {
      bottom: -1
    }]
  }))) : null);
});
export default /*#__PURE__*/React.memo(DurationScroll);
//# sourceMappingURL=DurationScroll.js.map